/*
 * =====================================================================================
 *
 *       Filename:  insertionSort.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  06/07/18 17:36:53
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Andy (https://github.com/andy-y-li), andy_y_li@163.com
 *        Company:  
 *
 * =====================================================================================
 */

#include "create_rand.h"
#include <stdio.h>// 分类 ------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)
// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定

/*
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5
*/
void InsertionSort(int *A, int n) 
{
    //  类似抓扑克牌排序
    for (int i = 1; i < n; i++) {
        int get = A[i];  // 右手抓到一张扑克牌
        int j = i - 1;    // 拿在左手上的牌总是排序好的
        while (j >= 0 && A[j] > get) { // 将抓到的牌与手牌从右向左进行比较
            A[j + 1] = A[j];     // 如果该手牌比抓到的牌大，就将其右移
            j--;
        }
        A[j + 1] = get;  // 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序
                         // 未变，所以插入排序是稳定的)
    }
}

int main()
{
    int A[10];
    create_rand(A, 10);
    show(A, 10);

    InsertionSort(A, 10);

    printf("插入排序结果：");
    show(A, 10);

    return 0;
}
